#region Prolog

#****Begin: Generated Statements***
#****End: Generated Statements****




#$$
#$$ Processus
#$$ - EXPORT_GENERIQUE_DATA_CSV
#$$
#$$ Description
#$$ - Export au format CSV toutes les valeurs (numerique et chaine) level 0 des éléments définis (aggrégés ou niveau fin) en parametre
#$$ - Valable pour tout cube ayant au max 20 dimensions
#$$ - /!\ Attention le process n'extrait pas les valeurs consolidées
#$$
#$$ Date révision & motif
#$$ 
#$$
#$$ Date création
#$$ - 02/07/2018
#$$
#$$ Fait par
#$$ - Laurent Mariotte
#$$
#$$ Paramètres
#$$ - pConfirmer
#$$ - pCube
#$$ - pScenario
#$$ - pVersion
#$$ - pAnnee
#$$ - pMois
#$$ - pPrestation
#$$ - pOrga
#$$ - pIndicateur
#$$ - pDecimalSeparator
#$$
#$$ Process appelé par
#$$ 
#$$
#$$ Commentaires
#$$ -


# -------------------------------------------------------------------------------------
# Variables globales utilisateur
# -------------------------------------------------------------------------------------

cCube_GLOBAL_VARIABLES = 'Z_PARAM';
cCube_PROCESS_ADMINISTRATION ='Z_PARAM';
cDim_Clients ='}Clients';
cMODE_DEBUG = 'MODE_DEBUG';
cCOMMENT = 'VALEUR';
cVALUE = 'VALUE';
cLOG_LEVEL = 'LOG_LEVEL';
cCSV = '.CSV';
cLOG = '.LOG';

# -------------------------------------------------------------------------------------
# Variables numériques
# -------------------------------------------------------------------------------------
#nDebug = cellgetn(cCube_GLOBAL_VARIABLES , cMODE_DEBUG , cVALUE);
nBoolTitle = 0;
nAnnee = 0;
nMois = 0;
nNumberofRecords = 0;

# -------------------------------------------------------------------------------------
# Variables string
# -------------------------------------------------------------------------------------
sLocalTime = today(1) | '_' | subst(TIME,1,2) | 'h' | subst(TIME,4,2);
sTimeStart_Sec =  StringToNumber(TimSt (Now, '\h'))*3600 +StringToNumber(TimSt (Now, '\i'))*60+StringToNumber(TimSt (Now, '\s'));
sTimeStamp = TimSt( Now, '\Y\m\d\h\i\s' );
sPeriodeCourante = TimSt( Now, '\Y-\m' );
sRandomInt = NumberToString( INT( RAND( ) * 100000 ));
sUSER = TM1User;
if( dimix( cDim_Clients , sUSER ) = 0 );
    # Si le user n'existe pas dans la dimension client on associe Admin aux user
    # pour gérer le cas des tâches schedulées
    sUSER = 'Admin';
endif;
sPRO_NAME = GetProcessName();
sSTATUS = 'KO';
sDate = '';
sCubeSource = pCube;
sViewSource ='z_temp_View_' |pCube | '_' | sPRO_NAME;
sSubSource ='z_temp_Sub_' |pCube | '_' | sPRO_NAME;
sErrorMessage = '';

# -------------------------------------------------------------------------------------
# DatasourceASCII
# -------------------------------------------------------------------------------------
# Suppression des quotes lors de l'export en CSV et formattage
## 2017-07-19 : Mise en commentaire des DatasourceASCII car non pris en compte dans l'onglet DATA, cf bug IBM : http://www-01.ibm.com/support/docview.wss?uid=swg1PM78147
#DatasourceASCIIHeaderRecords = STRINGTONUMBER(cellgets(cCube_PROCESS_ADMINISTRATION,sPRO_NAME,'DATASOURCE_ASCII_Header_Records',cCOMMENT));
#DatasourceASCIIThousandSeparator = cellgets(cCube_PROCESS_ADMINISTRATION,sPRO_NAME,'DATASOURCE_ASCII_Thousand_Separator',cCOMMENT);
#DatasourceASCIIDecimalSeparator = cellgets(cCube_PROCESS_ADMINISTRATION,sPRO_NAME,'DATASOURCE_ASCII_Decimal_Separator',cCOMMENT);
#DatasourceASCIIDelimiter = cellgets(cCube_PROCESS_ADMINISTRATION,sPRO_NAME,'DATASOURCE_ASCII_Delimiter',cCOMMENT);
#DatasourceASCIIQuoteCharacter = cellgets(cCube_PROCESS_ADMINISTRATION,sPRO_NAME,'DATASOURCE_ASCIIQuoteCharacter',cCOMMENT);
DatasourceASCIIQuoteCharacter='';
# Delimiter = ';'
DatasourceASCIIDelimiter=Char(59);
DatasourceASCIIThousandSeparator = ' ';
DatasourceASCIIDecimalSeparator =',';

# -------------------------------------------------------------------------------------
# Variables Dossiers interface user
# -------------------------------------------------------------------------------------
# Définition du dossier d'export
#sINTFC_INTERFACE_FOLDER = cellgets(cCube_GLOBAL_VARIABLES,'SAS_ARCHIVE','VALEUR');
sINTFC_INTERFACE_FOLDER = CellGets(cCube_GLOBAL_VARIABLES,'INPUT','VALEUR');
#sNAME_FOLDER_INTERFACE_EXPORT_CUBE = cellgets(cCube_GLOBAL_VARIABLES,'NAME_FOLDER_INTERFACE_EXPORT_CUBE',cCOMMENT);
#sNAME_FOLDER_EXPORT = cellgets(cCube_GLOBAL_VARIABLES,'NAME_FOLDER_EXPORT',cCOMMENT);
#sNAME_FOLDER_LOG = cellgets(cCube_GLOBAL_VARIABLES,'NAME_FOLDER_LOG',cCOMMENT);

# fichiers de log standard et csv
sLog_Dir =  GetProcessErrorFileDirectory;
#sLog_File = sINTFC_INTERFACE_FOLDER | sNAME_FOLDER_INTERFACE_EXPORT_CUBE | '\' | sNAME_FOLDER_LOG | '\' | 'Export_' | pCube | '_' |  sTimeStamp | cLOG;
sLog_check = sLog_Dir | 'Zcheck' | pCube | '_' |  sTimeStamp | '.csv';
sLog_File =sLog_Dir  | 'Export_' | pCube | '_' |  sTimeStamp | '.log';
#sOut_File = sINTFC_INTERFACE_FOLDER | 'Export_' | pCube | '_' |  sTimeStamp | cCSV;

if(pScenario @='');
vScenario ='ALL_PHASE';
else;
vScenario = pScenario;
endif;

if(pOrga @='');
vOrga = 'ALL_IMM';
else;
vOrga = pOrga;
endif;

if(pAnnee @='');
vAnnee ='ALL_YEAR';
else;
vAnnee =pAnnee;
endif;


# -------------------------------------------------------------------------------------
# Calcul du nombre de dimensions dans le cube                      
# -------------------------------------------------------------------------------------
nNbDim = 1;
While( TABDIM(pCube, nNbDim) @<>' ' );
nNbDim = nNbDim + 1;   
End;
nNbDim = nNbDim - 1;   
sDimLast = TabDim ( pCube , nNbDim );
nDimLast =  nNbDim;
#asciioutput(slog_check, sDimLast, numbertostring(nDimLast));
#processquit;

# -------------------------------------------------------------------------------------
# Identification des dimensions utilisées dans les parametres                   
# -------------------------------------------------------------------------------------
nIndex = 1;
While (nIndex <= nNbDim);
 sDim = TabDim ( pCube, nIndex);
  if(SCAN('T_PHASES',sDim) <> 0);
    sDimScenario = TabDim ( pCube, nIndex);
  elseif(SCAN('G_SCENARIOS',sDim) <> 0);
    sDimVersion = TabDim ( pCube, nIndex);
  elseif(SCAN('ANNEE',sDim) <> 0);
    sDimAnnee = TabDim ( pCube, nIndex);
  elseif(SCAN('MOIS',sDim) <> 0);
    sDimMois = TabDim ( pCube, nIndex); 
  elseif(SCAN('PRESTATION',sDim) <> 0);
    sDimPrestation = TabDim ( pCube, nIndex);
  elseif(SCAN('A_IMMEUBLES',sDim) <> 0);
    sDimOrga = TabDim ( pCube, nIndex);
  # Dimension indicateur identifiée par IND, VALUE et VALEUR hors dimension contenant INDEX (ex : SMB_INDEX_VALUE)
  elseif(SCAN('IND',sDim) <> 0 % (SCAN('INDEX',sDim) =0 & (SCAN('VALUE',sDim) <> 0 % SCAN('VALEUR',sDim) <> 0 ) ) );
    sDimIndicateur = TabDim ( pCube, nIndex);
  endif;
 nIndex = nIndex + 1;
End;


# -------------------------------------------------------------------------------------
# Transformation 
# -------------------------------------------------------------------------------------

# Gestion d'alias -> nom de code 
pScenario = DIMNM(sDimScenario,DIMIX(sDimScenario, pScenario));
pVersion = DIMNM(sDimVersion,DIMIX(sDimVersion, pVersion));
pAnnee = DIMNM(sDimAnnee,DIMIX(sDimAnnee, pAnnee));
pMois = DIMNM(sDimMois,DIMIX(sDimMois, pMois));
pPrestation = DIMNM(sDimPrestation,DIMIX(sDimPrestation, pPrestation));
pOrga = DIMNM(sDimOrga,DIMIX(sDimOrga, pOrga));
pIndicateur = DIMNM(sDimIndicateur,DIMIX(sDimIndicateur, pIndicateur));

# Définition d'un '.' en valeur par défaut si non renseigné
if(pDecimalSeparator @= ' ');
  pDecimalSeparator = '.';
endif;



#If(pOrga@<>'');
#sOut_File = sINTFC_INTERFACE_FOLDER | 'Export_' | pCube | '_' | pScenario| '_' | pAnnee  | '_' | pOrga| cCSV;
#else;
#sOut_File = sINTFC_INTERFACE_FOLDER | 'Export_' | pCube | '_' | pScenario| '_' | pAnnee | cCSV;
#endif;


If(pOrga@<>'');
sOut_File =  sINTFC_INTERFACE_FOLDER |  'BACKUP_BUDGET\' | pAnnee |'\' | pScenario | '_' | pAnnee  | '_' |  pCube | '_' | pOrga| '.csv';
else;
sOut_File =  sINTFC_INTERFACE_FOLDER | 'BACKUP_BUDGET\' | pAnnee |'\' | pScenario| '_' | pAnnee  | '_' | pCube| '.csv';
endif;



# -------------------------------------------------------------------------------------
#  Controle de coherence
# -------------------------------------------------------------------------------------
sErrorMessage = '';

if ( pConfirmer @<> 'OUI' );
  sErrorMessage = 'Confirmation echouée';
  processbreak;
endif;

if(cubeExists(sCubeSource) = 0);
  sErrorMessage = 'cube inexistant' ;
  processbreak;
endif;

if(DIMIX(sDimScenario, pScenario) = 0 & pScenario @<> ' ');
  sErrorMessage = 'Scenario inexistant' ;
  processbreak;
endif;

if(DIMIX(sDimVersion, pVersion) = 0 & pVersion @<> ' ');
  sErrorMessage = 'Version inexistante' ;
  processbreak;
endif;

if(DIMIX(sDimAnnee, pAnnee) = 0 & pAnnee @<> ' ');
  sErrorMessage = 'Annee inexistante' ;
  processbreak;
endif;

if(DIMIX(sDimMois, pMois) = 0 & pMois @<> ' ');
  sErrorMessage = 'Mois inexistant' ;
  processbreak;
endif;

if(DIMIX(sDimPrestation, pPrestation) = 0 & pPrestation @<> ' ');
  sErrorMessage = 'Prestation inexistante' ;
  processbreak;
endif;

if(DIMIX(sDimOrga, pOrga) = 0 & pOrga @<> ' ');
  sErrorMessage = 'Immeuble inexistant' ;
  processbreak;
endif;

if(DIMIX(sDimIndicateur, pIndicateur) = 0 & pIndicateur @<> ' ');
  sErrorMessage = 'Indicateur inexistant' ;
  processbreak;
endif;




# -------------------------------------------------------------------------------------
# Définition des dimensions du cube
# -------------------------------------------------------------------------------------
sDim1=TABDIM(sCubeSource,1);
sDim2=TABDIM(sCubeSource,2);
sDim3=TABDIM(sCubeSource,3);
sDim4=TABDIM(sCubeSource,4);
sDim5=TABDIM(sCubeSource,5);
sDim6=TABDIM(sCubeSource,6);
sDim7=TABDIM(sCubeSource,7);
sDim8=TABDIM(sCubeSource,8);
sDim9=TABDIM(sCubeSource,9);
sDim10=TABDIM(sCubeSource,10);
sDim11=TABDIM(sCubeSource,11);
sDim12=TABDIM(sCubeSource,12);
sDim13=TABDIM(sCubeSource,13);
sDim14=TABDIM(sCubeSource,14);
sDim15=TABDIM(sCubeSource,15);
sDim16=TABDIM(sCubeSource,16);
sDim17=TABDIM(sCubeSource,17);
sDim18=TABDIM(sCubeSource,18);
sDim19=TABDIM(sCubeSource,19);
sDim20=TABDIM(sCubeSource,20);

# -------------------------------------------------------------------------------------
# Création  d'une vue Source
# -------------------------------------------------------------------------------------
if (ViewExists(sCubeSource, sViewSource) = 1);
   ViewDestroy(sCubeSource, sViewSource);
   ViewCreate(sCubeSource, sViewSource);
else;
   ViewCreate(sCubeSource, sViewSource);
endif;

# -------------------------------------------------------------------------------------
# Création  des sous ensembles
# -------------------------------------------------------------------------------------

nDim = 1;
While( TabDim( pCube, nDim ) @<> '' );
  sDim = TabDim( pCube, nDim );
  if( SubsetExists( sDim,sSubSource) = 1 );
   SubsetDeleteAllElements(sDim, sSubSource);
  else;
   SubsetCreate(sDim,sSubSource);
  endif;
  nDim = nDim + 1;
End;


# -------------------------------------------------------------------------------------
# Subset : Ajout des éléments
# -------------------------------------------------------------------------------------

nDim = 1;
While ( nDim <= nNbDim );
    sDim = TABDIM(pCube, nDim);

    if(sDim @= sDimScenario & pScenario @<> ' ');
       SubsetDestroy(sDim, sSubSource);
       SubsetCreatebyMDX(sSubSource, '{TM1FILTERBYLEVEL( {TM1DRILLDOWNMEMBER({[ '| sDim |' ].[ '|pScenario|' ]}, ALL, RECURSIVE )}, 0)}' );
       # Conversion du Subset dynamique en statique   
         SubsetElementInsert( sDim, sSubSource, Dimnm( sDim, 1 ), 1 );
         SubsetElementDelete( sDim, sSubSource, 1 );
    elseif(sDim @= sDimVersion & pVersion @<> ' ');
       SubsetDestroy(sDim, sSubSource);
       SubsetCreatebyMDX(sSubSource, '{TM1FILTERBYLEVEL( {TM1DRILLDOWNMEMBER({[ '| sDim |' ].[ '|pVersion|' ]}, ALL, RECURSIVE )}, 0)}' );
       # Conversion du Subset dynamique en statique   
         SubsetElementInsert( sDim, sSubSource, Dimnm( sDim, 1 ), 1 );
         SubsetElementDelete( sDim, sSubSource, 1 );
    elseif(sDim @= sDimAnnee & pAnnee @<> ' ');
       SubsetDestroy(sDim, sSubSource);
       SubsetCreatebyMDX(sSubSource, '{TM1FILTERBYLEVEL( {TM1DRILLDOWNMEMBER({[ '| sDim |' ].[ '|pAnnee|' ]}, ALL, RECURSIVE )}, 0)}' );
       # Conversion du Subset dynamique en statique   
         SubsetElementInsert( sDim, sSubSource, Dimnm( sDim, 1 ), 1 );
         SubsetElementDelete( sDim, sSubSource, 1 );
    elseif(sDim @= sDimMois & pMois @<> ' ');
       SubsetDestroy(sDim, sSubSource);
       SubsetCreatebyMDX(sSubSource, '{TM1FILTERBYLEVEL( {TM1DRILLDOWNMEMBER({[ '| sDim |' ].[ '|pMois|' ]}, ALL, RECURSIVE )}, 0)}' );
       # Conversion du Subset dynamique en statique   
         SubsetElementInsert( sDim, sSubSource, Dimnm( sDim, 1 ), 1 );
         SubsetElementDelete( sDim, sSubSource, 1 );
    elseif(sDim @= sDimPrestation & pPrestation @<> ' ');
       SubsetDestroy(sDim, sSubSource);
       SubsetCreatebyMDX(sSubSource, '{TM1FILTERBYLEVEL( {TM1DRILLDOWNMEMBER({[ '| sDim |' ].[ '|pPrestation|' ]}, ALL, RECURSIVE )}, 0)}' );
       # Conversion du Subset dynamique en statique   
         SubsetElementInsert( sDim, sSubSource, Dimnm( sDim, 1 ), 1 );
         SubsetElementDelete( sDim, sSubSource, 1 );
    elseif(sDim @= sDimOrga & pOrga @<> ' ');
       SubsetDestroy(sDim, sSubSource);
       SubsetCreatebyMDX(sSubSource, '{TM1FILTERBYLEVEL( {TM1DRILLDOWNMEMBER({[ '| sDim |' ].[ '|pOrga|' ]}, ALL, RECURSIVE )}, 0)}' );
       # Conversion du Subset dynamique en statique   
         SubsetElementInsert( sDim, sSubSource, Dimnm( sDim, 1 ), 1 );
         SubsetElementDelete( sDim, sSubSource, 1 );
    elseif(sDim @= sDimIndicateur & pIndicateur @<> ' ');
       SubsetDestroy(sDim, sSubSource);
       SubsetCreatebyMDX(sSubSource, '{TM1FILTERBYLEVEL( {TM1DRILLDOWNMEMBER({[ '| sDim |' ].[ '|pIndicateur|' ]}, ALL, RECURSIVE )}, 0)}' );
       # Conversion du Subset dynamique en statique   
         SubsetElementInsert( sDim, sSubSource, Dimnm( sDim, 1 ), 1 );
         SubsetElementDelete( sDim, sSubSource, 1 );
    else;
       # Boucle sur tous les levels 0 des autres dimensions
       nIndex = 1;
       While (nIndex <= DIMSIZ(sDim));
       sElement = DIMNM(sDim, nIndex);
         if(ELLEV(sDim,sElement ) = 0);
             SubsetElementInsert(sDim, sSubSource, sElement, 1);
         endif;
       nIndex = nIndex + 1;
       End;

    endif;
    nDim = nDim + 1;
End;

# -------------------------------------------------------------------------------------
# Subsets : Affectation des subsets à la vue
# -------------------------------------------------------------------------------------
nDim = 1;
While( nDim <= nNbDim );
  sDim = TABDIM(pCube, nDim);
      ViewSubsetAssign(pCube, sViewSource,sDim, sSubSource);
  nDim = nDim + 1;
End;


# -------------------------------------------------------------------------------------
# Définition de la Datasource
# -------------------------------------------------------------------------------------
DataSourceType = 'VIEW';
DatasourceNameForServer = sCubeSource;
DatasourceCubeview = sViewSource;

# -------------------------------------------------------------------------------------
# Filtre sur les éléments pour lesquels il y a des données
# -------------------------------------------------------------------------------------
ViewExtractSkipZeroesSet (sCubeSource,DatasourceCubeview, 1);
ViewExtractSkipCalcsSet(sCubeSource, DatasourceCubeview, 1);
ViewExtractSkipRuleValuesSet(sCubeSource, DatasourceCubeview, 0);

## End Prolog
#endregion
#region Metadata

#****Begin: Generated Statements***
#****End: Generated Statements****


## End MetaData
#endregion
#region Data

#****Begin: Generated Statements***
#****End: Generated Statements****


# -------------------------------------------------------------------------------------
# Ajout de la ligne d'en-tête
# -------------------------------------------------------------------------------------
if ( nBoolTitle = 0 );
    nDim = 1;
    While( nDim <= nNbDim);
     sDim = 'v' | TABDIM(pCube, nDim);
       if(nDim =1);
         sLigne = sDim;
       else;
         sLigne = sLigne | ';' | sDim;
       endif;
     nDim = nDim + 1;
    End;
    nBoolTitle = 1;
    # Export des entetes de dimension 
    AsciiOutput(sOut_File,sLigne,'Valeur');
endif;

# -------------------------------------------------------------------------------------
# Traitement des lignes avec données
# -------------------------------------------------------------------------------------

# Boucle pour concatenation des variables
nDim = 1;
While( nDim <= nNbDim);
    sElementName = EXPAND( '%' | 'v' | NumberToString(nDim) | '%');
       if(nDim =1);
         sFullElementName = sElementName;
       else;
         sFullElementName = sFullElementName | ';' | sElementName;
       endif;
    nDim = nDim + 1;
End;


# Ajout du +1 pour prendre en compte la variable vX contenant les données
# nb de dimensions du cube +1 = valeur au croisement des cellules
nVarValeur = nNbDim +1;
# Utilisation de la fonction EXPAND pour convertir la variable en élement de dimension
sVarValeur = EXPAND( '%' | 'v' | NumberToString(nVarValeur) | '%');


# Permet de recuperer le nom de l'élément pour tester son type
sVarIndicateur = EXPAND( '%' | 'v' | NumberToString(nDimLast) | '%');
# Retours attendus de la fonction DTYPE : "N" pour numerique, "C" : consolidation (cas non possible ici), "S" pour string.

If(DTYPE(sDimLast,sVarIndicateur) @= 'S');
    sValeur = sVarValeur ;
else;
    nValeur = StringToNumber(sVarValeur);
    sValeur = NumberToStringEx(nValeur,'#,0.#########', pDecimalSeparator, ' ');
endif;

# Export des éléments & données
AsciiOutput( sOut_File ,sFullElementName,sValeur);

nNumberofRecords = nNumberofRecords +1;

## End pPrestation
#endregion
#region Epilog

#****Begin: Generated Statements***
#****End: Generated Statements****



#--- Gestion des exports à vide (pour gestion des erreurs en import)
if(nNumberofRecords=0);
# -------------------------------------------------------------------------------------
# Ajout de la ligne d'en-tête
# -------------------------------------------------------------------------------------
if ( nBoolTitle = 0 );
    nDim = 1;
    While( nDim <= nNbDim);
     sDim = 'v' | TABDIM(pCube, nDim);
       if(nDim =1);
         sLigne = sDim;
       else;
         sLigne = sLigne | ';' | sDim;
       endif;
     nDim = nDim + 1;
    End;
    nBoolTitle = 1;
    # Export des entetes de dimension 
    AsciiOutput(sOut_File,sLigne,'Valeur');
endif;
endif;


# -------------------------------------------------------------------------------------
#  Boucle pour remplacer un caractere
# -------------------------------------------------------------------------------------
sElementSource = sOut_File;
sCarSource = '\';
sCarCible = '/';

sElementCible = '';
nCar=1;
While( nCar <= LONG(sElementSource) );
sCar = SUBST(sElementSource, nCar, 1);
  if(sCar @=sCarSource);
    sCar = sCarCible;
  endif;
sElementCible = sElementCible | sCar;
nCar = nCar + 1;
End;
sOut_FileLinked = 'File://' | sElementCible;


# -------------------------------------------------------------------------------------
#  Log : Parametres / Utilisateur / nb de lignes
# -------------------------------------------------------------------------------------
AsciiOutput(sLog_File,  'Export du cube ' | pCube | ' executé par ' | sUSER | ' le ' | sLocalTime );
AsciiOutput(sLog_File, 'Parametres renseignés :'); 
AsciiOutput(sLog_File, 'Confirmer -> ' | pConfirmer);
AsciiOutput(sLog_File, 'Scenario -> ' | pScenario );
AsciiOutput(sLog_File, 'Version -> ' | pVersion  );
AsciiOutput(sLog_File, 'Année -> ' | pAnnee );
AsciiOutput(sLog_File, 'Mois -> ' | pMois );
AsciiOutput(sLog_File, 'Prestation -> ' | pPrestation );
AsciiOutput(sLog_File, 'Organisation -> ' | pOrga );
AsciiOutput(sLog_File, 'Indicateur -> ' | pIndicateur );
AsciiOutput(sLog_File, 'Nombre de lignes exportées ' | NumberToString(nNumberofRecords) | ' éléments');
AsciiOutput(sLog_File, ' -------------------------------------------------------------------------------------');
AsciiOutput(sLog_File, 'Accès au fichier : ' | sOut_FileLinked);
AsciiOutput(sLog_File, ' -------------------------------------------------------------------------------------');


# -------------------------------------------------------------------------------------
#  Gestion des messages d'erreur
# -------------------------------------------------------------------------------------

if ( sErrorMessage @<> '' );
   itemreject(  sErrorMessage);
endif;

# -------------------------------------------------------------------------------------
#  Suppression vue et subsets
# -------------------------------------------------------------------------------------

#****Suppression de la vue ***#
#---------------------------------------------------------
If (ViewExists(sCubeSource,sViewSource) = 1);
   ViewDestroy(sCubeSource, sViewSource);
Endif;

#****Suppression des subsets ****#
#---------------------------------------------------------
nDim = 1;
While( TabDim( sCubeSource, nDim ) @<> '' );
  sDim = TabDim( sCubeSource, nDim );
   SubsetDestroy(sDim, sSubSource);
  nDim = nDim + 1;
End;


## End Epilog
#endregion